#' nsdm.bigextract
#'
#' Parallel loading and spatiotemporal extraction of large raster sets
#'
#' @param cov A character vector indicating paths for each individual raster layer
#' @param data The nsdm.pseudoabsences object to be used for covariate extraction
#' @param rst_ref Raster used as reference (cell identifiers, crs, extent etc.)
#' @param cov_info Data.frame containing key information on covariate, as generated by nsdm.covinfo
#' @param t_match Logical for doing temporal matching (TRUE) or not (FALSE)
#' @param tmatch_scheme A character string for the name of temporal matching scheme considered ("npts"=nearest previous time slice or "nts"=nearest time slice)
#' @param p_int Numeric interval for identifying period interval (e.g. 1981:2010 for historical climate normals)
#' @param ex_pint Logical for considering period interval covariates as static (TRUE) or not (FALSE)
#' @param nzvt Numeric threshold for the minimal number of unique values for a covariate to bo kept in the candidate set
#' @param nsplits Number of cores to be used for parallel extraction
#'
#' @return An updated nsdm.pseudoabsences object
#' @author Antoine Adde (aadde@unil.ch)
#' @export

nsdm.bigextract<-function(cov, data, rst_ref, cov_info, t_match=FALSE, tmatch_scheme="npts", p_int=NULL, ex_pint=TRUE, nzvt=10, nsplits=ncores){

  # Get data
  xy<-data@xy
  pa<-data@pa
  years<-data@years
  
  # Isolate fst and rds covariates
  cov_rds<-cov[grep(".rds", cov)] # should only be mainGLO
  cov_fst<-cov[grep(".fst", cov)] 

  ### ------------------------
  ### Arrange layers for temporal matching or not
  ### ------------------------
  # Retrieve cov-info table
  cov_info_fst<-data.frame(cov_info[match(gsub(".fst","",basename(cov_fst)), gsub(".rds","",basename(cov_info$file))),])
  times<-cov_info_fst[,c("start_year", "end_year", "variable", "dataset")]
  times[,1:2] <- lapply(times[,1:2], function(x) as.numeric(as.character(x)))
  times$id<-1:nrow(times) 

if(t_match){
  # Identify layers for which temporal information is available
  suppressMessages(tempo_t<-times[complete.cases(times), ])
  suppressMessages(stat_t<-times[!complete.cases(times), ])
  
  # Consider period interval layers as static ones if requested...
  if(is.numeric(p_int) && ex_pint==TRUE){
  per_int_ix<-which(tempo_t$start_year==min(p_int) & tempo_t$end_year==max(p_int))
  stat_t<-rbind(stat_t, tempo_t[per_int_ix,])
  tempo_t<-tempo_t[-per_int_ix,]
  }
  ## ...or not (but use them for pseudoabsences)
  if(is.numeric(p_int) && ex_pint==FALSE){
  per_int_ix<-which(tempo_t$start_year==min(p_int) & tempo_t$end_year==max(p_int))
  stat_t<-rbind(stat_t, tempo_t[per_int_ix,])
  }
  
  # Isolate dynamic (to match) and static (no match) layers and subset info tables
  cov_tomatch<-cov_fst[tempo_t$id]
  cov_tomatch_times<-tempo_t
  
  cov_nomatch<-cov_fst[stat_t$id]
  cov_nomatch_times<-stat_t
  
  # Isolate static variables also in dynamic variables (e.g. period interval covariate)
  cov_diff<-which(cov_nomatch_times$variable %in% cov_tomatch_times$variable) # period interval covariates
  
  if(length(cov_diff) > 0) {
  cov_nomatch_diff<-cov_nomatch[-cov_diff]
  cov_nomatch_diff_times<-cov_nomatch_times[-cov_diff,]  
  } else {
  cov_nomatch_diff<-cov_nomatch
  cov_nomatch_diff_times<-stat_t
  }
  
  # Settings if no temporal matching
  }  else {
  cov_tomatch<-NULL
  cov_nomatch_diff<-cov_fst
  cov_nomatch_diff_times<-times
  cov_nomatch<-cov_fst
  cov_nomatch_times<-times
  }

  ### ------------------------
  ### Extract presences
  ### ------------------------
  threads_fst(nr_of_threads = 1)
  # static covariates (only if not included in dynamic ones)
  if(length(cov_nomatch_diff)>0){
  cells<-cellFromXY(rst_ref, xy[pa==1,])
  suppressMessages(xt_pres<-mclapply(cov_nomatch_diff, function(i){
  r<-read_fst(i)
  xt<-data.frame(r[cells,1])
  names(xt)<-names(r)
  return(xt)
  }, mc.cores=ncores))
  xt_pres_sta<-do.call(cbind, xt_pres)
  names(xt_pres_sta)[grep("bioclim", names(xt_pres_sta))]<-grep("bio", cov_nomatch_diff_times$variable, value=T)
  }
  
  # Dynamic covariates
  if(length(cov_tomatch)>0){
  cells<-cellFromXY(rst_ref, xy[pa==1,])
  ## Extract
  suppressMessages(xt_pres<-mclapply(cov_tomatch, function(i){
  r<-read_fst(i)
  xt<-data.frame(r[cells,1])
  names(xt)<-names(r)
  return(xt)
  }, mc.cores=ncores))
  xt_pres<-do.call(cbind, xt_pres)
  ## For each row, identify year to be matched
  y<-years[pa==1]
  # Nearest previous time slice (e.g. climate)
  if(tmatch_scheme=="npts"){
  suppressWarnings(maxless <- sapply(y, function(z){max(cov_tomatch_times[,2][cov_tomatch_times[,2] <= z])}))
  y_ix<-which(!is.finite(maxless))
  if(length(y_ix)>0) maxless[y_ix]<-min(cov_tomatch_times$end_year)
  }
 # Nearest time slice (e.g. lulc)
  if(tmatch_scheme=="nts"){
  suppressWarnings(maxless <- sapply(y, function(z){cov_tomatch_times[,2][which.min(abs(rowMeans(cbind(cov_tomatch_times[,1],cov_tomatch_times[,2]))-z))]}))
  }
  y_pos<-lapply(1:length(maxless), function(t){cov_tomatch_times$end_year %in% maxless[t]})
  ## Thin accordingly
  xt_pres<-lapply(1:length(maxless), function(w){xt_pres[w,y_pos[[w]]]})
  # clean rename
  pers<-paste(unique(cov_tomatch_times[,1]), unique(cov_tomatch_times[,2]), sep="_")
  xt_pres<-lapply(xt_pres, function(r){
  names(r)<-stri_replace_all_regex(names(r),
                                   pattern=c(pers),
                                   replacement=rep(paste(min(p_int), max(p_int), sep="_"),length(pers)),
								   vectorize=F);  return(r)})
  ## Finalize
  xt_pres_dyn<- do.call(rbind, xt_pres)
  # clean rename if needed
  names(xt_pres_dyn)[grep("bioclim", names(xt_pres_dyn))]<-grep("bio", cov_tomatch_times$variable, value=T)
  }
  
  # Combine static and dynamic sets
  sets<-c("xt_pres_sta", "xt_pres_dyn")
  exi<-c(exists(sets[1]), exists(sets[2]))
  xt_pres<-do.call(cbind, lapply(sets[exi], get, sys.frame(sys.parent(0))))
  
  ### ------------------------
  ### Extract pseudoabsences
  ### ------------------------
  cells<-cellFromXY(rst_ref, xy[pa==0,])
  suppressMessages(xt_abs<-mclapply(cov_nomatch, function(i){
  r<-read_fst(i)
  xt<-data.frame(r[cells,1])
  names(xt)<-names(r)
  return(xt)
  }, mc.cores=ncores))
  ## Finalize
  xt_abs<-do.call(cbind, xt_abs)
  # clean rename if needed
  names(xt_abs)[grep("bioclim", names(xt_abs))]<-grep("bio", cov_nomatch_times$variable, value=T)
  
  ### ------------------------
  ### Extract mainGLO
  ### ------------------------
if(length(cov_rds)>0){
cells<-cellFromXY(rst_ref, xy)
l<-readRDS(cov_rds)
r<-as.data.frame(l)
xt_glo<-data.frame(r[cells,1])
names(xt_glo)<-names(r)
}

### ------------------------
### Combine everything
### ------------------------
# rbind presences and absences
env_vars<-rbind(xt_pres, xt_abs)

# cbind mainGLO
if(length(cov_rds)>0){
env_vars<-cbind(env_vars, xt_glo)
}

# Clean for rows with NA values
na_ix<-which(complete.cases(env_vars)==FALSE)
if(length(na_ix)>0){
env_vars<-env_vars[-na_ix,]
xy<-xy[-na_ix,]
pa<-pa[-na_ix]
years<-years[-na_ix]
}

# Clean for columns with unique value for p==1
lenv<-(apply(env_vars[which(pa==1),], 2, function(x) length(unique(x))))
if(length(which(lenv==1))>0){
env_vars<-env_vars[,-which(lenv==1)]
}

# Clean for near-zero variance columns
if(is.numeric(nzvt)){
if(length(which(apply(env_vars, 2, function(x) length(unique(x)))<nzvt))>0){
env_vars<-env_vars[,-which(apply(env_vars, 2, function(x) length(unique(x)))<nzvt)]}
}

# Ecrase with updated data
data@env_vars<-env_vars
data@xy<-xy
data@pa<-pa
data@years<-years

return(data)
}
